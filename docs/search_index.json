[
["index.html", "Beginner R Workshop Welcome", " Beginner R Workshop Ann Arbor R User Group Welcome This is the core content for the Ann Arbor R User Group Beginner Workshops. Each workshop consists of two sessions in which we provide hands-on Welcome to the R community. "],
["requirements.html", "Requirements", " Requirements These lessons assume no prior knowledge of the skills or tools, but working through this lesson requires working copies of the software described below. To most effectively use these materials, please make sure to install everything before working through this lesson. R and RStudio R is a programming language that is especially powerful for data exploration, visualization, and statistical analysis. To interact with R, we use RStudio. Get R from the R project website. Get Rstudio from the RStudio website "],
["slack.html", "Slack", " Slack We’ll use Slack to communicate during the workshop. The AARUG slack group is also a great resource for hearing about R-related events, announcements, and receiving help with your R code. Request to join the AARUG slack group here. "],
["contributing.html", "Contributing", " Contributing The original lesson plans were adapted from the Software Carpentry and Data Carpentry projects. You can contribute to these lessons by clicking the Edit button from any page. Contributors Michelle Berry, Ellis Valentiner, Rob Weyant, Clayton Yochum, Andrew Moore All authors and contributors: Ellis Valentiner Clayton Yochum -->"],
["1-basics-of-r.html", "Lesson 1 Basics of R Learning Objectives", " Lesson 1 Basics of R Learning Objectives Articulating motivations for using R Introduce participants to the RStudio interface Point to relevant information on how to get help, and understand how to ask well formulated questions R is a versatile, open source programming/scripting language that’s useful both for statistics but also data science. Inspired by the programming language S. Open source software under GPL. Superior (if not just comparable) to commercial alternatives. R has over 7,000 user contributed packages at this time. It’s widely used both in academia and industry. Available on all platforms. Not just for statistics, but also general purpose programming. For people who have experience in programmming: R is both an object-oriented and a so-called functional language Large and growing community of peers. "],
["1-1-awesome-r-tools.html", "1.1 Awesome R tools", " 1.1 Awesome R tools 1.1.1 Knitr/R-markdown Knitr is an R library that allows you to create dynamic code reports. Example: This BuzzFeed article, reporting on government surveillance planes, included all of their analysis as an R-markdown document. 1.1.2 Shiny Shiny is a web application framework built for R. Example: This is a shiny app to visualize and explore a movie dataset. 1.1.3 RStudio RStudio is an IDE- an integrated development environment. It allows us to write, execute, and debug R code. It also has several other nice features, accessible through its GUI (graphical user interface), that make it easier to use R. RStudio is such a popular tool among R users, that several other languages have tried to emulate it, such as Spyder for Python. Start RStudio – Let’s start learning about our tool. Rstudio’s layout includes 4 quadrants Scripts Console Environment/History Plotting/Packages/Help rstudio-image To adjust the layout of your quadrants go to Preferences &gt; Pane Layout "],
["1-2-interacting-with-r.html", "1.2 Interacting with R", " 1.2 Interacting with R There are two main ways of interacting with R: using the console or by using script files (plain text files that contain your code). The console window is the place where R is waiting for you to tell it what to do, and where it will show the results of a command. You can type commands directly into the console, but they will be forgotten when you close the session. It is better to enter the commands in the script editor, and save the script. This way, you have a complete record of what you did, you can easily show others how you did it and you can do it again later on if needed. You can copy-paste into the R console, but the Rstudio script editor allows you to ‘send’ the current line or the currently selected text to the R console using the Ctrl-Enter shortcut. If R is ready to accept commands, the R console shows a &gt; prompt. If it receives a command (by typing, copy-pasting or sent from the script editor using Ctrl-Enter), R will try to execute it, and when ready, show the results and come back with a new &gt;-prompt to wait for new commands. If R is still waiting for you to enter more data because it isn’t complete yet, the console will show a + prompt. It means that you haven’t finished entering a complete command. This is because you have not ‘closed’ a parenthesis or quotation. If you’re in Rstudio and this happens, click inside the console window and press Esc; this should help you out of trouble. "],
["1-3-seeking-help.html", "1.3 Seeking help", " 1.3 Seeking help 1.3.1 I know the name of the function I want to use, but I’m not sure how to use it If you need help with a specific function, let’s say barplot(), you can type: ?barplot If you just need to remind yourself of the names of the arguments, you can use: args(lm) If the function is part of a package that is installed on your computer but don’t remember which one, you can type: ??geom_point 1.3.2 I want to use a function that does X, there must be a function for it but I don’t know which one… If you are looking for a function to do a particular task, you can use help.search() (but only looks through the installed packages): help.search(&quot;kruskal&quot;) If you can’t find what you are looking for, you can use the rdocumention.org website that search through the help files across all packages available. 1.3.3 I am stuck… I get an error message that I don’t understand Start by googling the error message. However, this doesn’t always work very well because often, package developers rely on the error catching provided by R. You end up with general error messages that might not be very helpful to diagnose a problem (e.g. “subscript out of bounds”). However, you should check stackoverflow. Search using the [r] tag. Most questions have already been answered, but the challenge is to use the right words in the search to find the answers: http://stackoverflow.com/questions/tagged/r The Introduction to R can also be dense for people with little programming experience but it is a good place to understand the underpinnings of the R language. The R FAQ is dense and technical but it is full of useful information. 1.3.4 Asking for help The key to get help from someone is for them to grasp your problem rapidly. You should make it as easy as possible to pinpoint where the issue might be. Try to use the correct words to describe your problem. For instance, a package is not the same thing as a library. Most people will understand what you meant, but others have really strong feelings about the difference in meaning. The key point is that it can make things confusing for people trying to help you. Be as precise as possible when describing your problem If possible, try to reduce what doesn’t work to a simple reproducible example. If you can reproduce the problem using a very small data.frame instead of your 50,000 rows and 10,000 columns one, provide the small one with the description of your problem. When appropriate, try to generalize what you are doing so even people who are not in your field can understand the question. If you want to share your object, provide either the raw file (i.e., your CSV file) with your script up to the point of the error (and after removing everything that is not relevant to your issue). Alternatively, in particular if your questions is not related to a data.frame, you can save any R object to a file: saveRDS(iris, file=&quot;/tmp/iris.rds&quot;) The content of this file is however not human readable and cannot be posted directly on stackoverflow. It can however be sent to someone by email who can read it with this command: some_data &lt;- readRDS(file=&quot;~/Downloads/iris.rds&quot;) Last, but certainly not least, always include the output of sessionInfo() as it provides critical information about your platform, the versions of R and the packages that you are using, and other information that can be very helpful to understand your problem. sessionInfo() ## R version 3.3.2 (2016-10-31) ## Platform: x86_64-apple-darwin16.1.0 (64-bit) ## Running under: macOS Sierra 10.12.1 ## ## locale: ## [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8 ## ## attached base packages: ## [1] stats graphics grDevices utils datasets methods base ## ## loaded via a namespace (and not attached): ## [1] backports_1.0.4 bookdown_0.3 magrittr_1.5 rprojroot_1.1 ## [5] tools_3.3.2 htmltools_0.3.5 rstudioapi_0.6 yaml_2.1.14 ## [9] Rcpp_0.12.8 stringi_1.1.2 rmarkdown_1.2 knitr_1.15.1 ## [13] stringr_1.1.0 digest_0.6.10 evaluate_0.10 1.3.5 Where to ask for help? Your friendly colleagues: if you know someone with more experience than you, they might be able and willing to help you. Stackoverflow: if your question hasn’t been answered before and is well crafted, chances are you will get an answer in less than 5 min. The R-help: it is read by a lot of people (including most of the R core team), a lot of people post to it, but the tone can be pretty dry, and it is not always very welcoming to new users. If your question is valid, you are likely to get an answer very fast but don’t expect that it will come with smiley faces. Also, here more than everywhere else, be sure to use correct vocabulary (otherwise you might get an answer pointing to the misuse of your words rather than answering your question). You will also have more success if your question is about a base function rather than a specific package. If your question is about a specific package, see if there is a mailing list for it. Usually it’s included in the DESCRIPTION file of the package that can be accessed using packageDescription(&quot;name-of-package&quot;). You may also want to try to email the author of the package directly. There are also some topic-specific mailing lists (GIS, phylogenetics, etc…), the complete list is here. 1.3.6 More resources The Posting Guide for the R mailing lists. How to ask for R help useful guidelines -->"],
["2-vectors-and-data-types.html", "Lesson 2 Vectors and Data Types 2 Learning Objectives", " Lesson 2 Vectors and Data Types 2 Learning Objectives Familiarize participants with R syntax Understand the concepts of objects and assignment Understand the concepts of vectors and data types Get exposed to a few functions "],
["2-1-creating-objects.html", "2.1 Creating objects", " 2.1 Creating objects You can get output from R simply by typing in math in the console 3 + 5 12/7 2*4 2^4 We can also comment what it is we’re doing # I am adding 3 and 5. R is fun! 3 + 5 What happens if we do that same command without the # sign in the front? I am adding 3 and 5. R is fun! 3 + 5 Now R is trying to run that sentence as a command, and it doesn’t work. Now we’re stuck over in the console. The + sign means that it’s still waiting for input, so we can’t type in a new command. To get out of this type Esc. This will work whenever you’re stuck with that + sign. It’s great that R is a glorified caluculator, but obviously we want to do more interesting things. To do useful and interesting things, we need to assign values to objects. To create objects, we need to give it a name followed by the assignment operator &lt;- and the value we want to give it. "],
["2-2-assignment-operator.html", "2.2 Assignment operator", " 2.2 Assignment operator For instance, instead of adding 3 + 5, we can assign those values to objects and then add them. # assign 3 to a a &lt;- 3 # assign 5 to b b &lt;- 5 # what now is a a # what now is b b # Add a and b a + b &lt;- is the assignment operator. It assigns values on the right to objects on the left. So, after executing x &lt;- 3, the value of x is 3. The arrow can be read as 3 goes into x. You can also use = for assignments but not in all contexts so it is good practice to use &lt;- for assignments. = should only be used to specify the values of arguments in functions, see below. In RStudio, typing Alt + - (push Alt, the key next to your space bar at the same time as the - key) will write &lt;- in a single keystroke. To view which objects we have stored in memory, we can use the ls() command ls() To remove objects we can use the rm() command rm(a) 2.2.1 Exercise What happens if we change a and then re-add a and b? Does it work if you just change a in the script and then add a and b? Did you still get the same answer after they changed a? If so, why do you think that might be? We can also assign a + b to a new variable, c. How would you do this? "],
["2-3-notes-on-objects.html", "2.3 Notes on objects", " 2.3 Notes on objects Objects can be given any name such as x, current_temperature, or subject_id. You want your object names to be explicit and not too long. They cannot start with a number (2x is not valid but x2 is). R is case sensitive (e.g., my_data is different from My_data). There are some names that cannot be used because they represent the names of fundamental functions in R (e.g., if, else, for, see here for a complete list). In general, even if it’s allowed, it’s best to not use other function names (e.g., c, T, mean, data, df, weights). In doubt check the help to see if the name is already in use. It’s also best to avoid dots (.) within a variable name as in my.dataset. There are many functions in R with dots in their names for historical reasons, but because dots have a special meaning in R (for methods) and other programming languages, it’s best to avoid them. It is also recommended to use nouns for variable names, and verbs for function names. It’s important to be consistent in the styling of your code (where you put spaces, how you name variable, etc.). In R, two popular style guides are Hadley Wickham’s and Google’s. When assigning a value to an object, R does not print anything. You can force to print the value by using parentheses or by typing the name: "],
["2-4-functions.html", "2.4 Functions", " 2.4 Functions The other key feature of R are functions. These are R’s built in capabilities. Some examples of these are mathematical functions, like sqrt and round. You can also get functions from libraries (which we’ll talk about in a bit), or even write your own. "],
["2-5-functions-and-their-arguments.html", "2.5 Functions and their arguments", " 2.5 Functions and their arguments Functions are “canned scripts” that automate something complicated or convenient or both. Many functions are predefined, or become available when using the function library() (more on that later). A function usually gets one or more inputs called arguments. Functions often (but not always) return a value. A typical example would be the function sqrt(). The input (the argument) must be a number, and the return value (in fact, the output) is the square root of that number. Executing a function (‘running it’) is called calling the function. An example of a function call is: sqrt(a) Here, the value of a is given to the sqrt() function, the sqrt() function calculates the square root. This function is very simple, because it takes just one argument. The return ‘value’ of a function need not be numerical (like that of sqrt()), and it also does not need to be a single item: it can be a set of things, or even a data set. We’ll see that when we read data files in to R. Arguments can be anything, not only numbers or filenames, but also other objects. Exactly what each argument means differs per function, and must be looked up in the documentation (see below). If an argument alters the way the function operates, such as whether to ignore ‘bad values’, such an argument is sometimes called an option. Most functions can take several arguments, but many have so-called defaults. If you don’t specify such an argument when calling the function, the function itself will fall back on using the default. This is a standard value that the author of the function specified as being “good enough in standard cases”. An example would be what symbol to use in a plot. However, if you want something specific, simply change the argument yourself with a value of your choice. Let’s try a function that can take multiple arguments round. round(3.14159) ## [1] 3 We can see that we get 3. That’s because the default is to round to the nearest whole number. If we want more digits we can see how to do that by getting information about the round function. We can use args(round) or look at the help for this function using ?round. args(round) ## function (x, digits = 0) ## NULL ?round We see that if we want a different number of digits, we can type digits=2 or however many we want. round(3.14159, digits = 2) ## [1] 3.14 If you provide the arguments in the exact same order as they are defined you don’t have to name them: round(3.14159, 2) ## [1] 3.14 However, it’s usually not recommended practice because it’s a lot of remembering to do, and if you share your code with others that includes less known functions it makes your code difficult to read. (It’s however OK to not include the names of the arguments for basic functions like mean, min, etc…) Another advantage of naming arguments, is that the order doesn’t matter. This is useful when there start to be more arguments. "],
["2-6-vectors-and-data-types-1.html", "2.6 Vectors and data types", " 2.6 Vectors and data types A vector is the most common and basic data structure in R, and is pretty much the workhorse of R. It’s basically just a list of values, mainly either numbers or characters. They’re special lists that you can do math with. You can assign this list of values to a variable, just like you would for one item. You can add elements to your vector simply by using the c() function, which stands for combine: one_to_five &lt;- c(1, 2, 3, 4, 5) one_to_five &lt;- 1:5 one_to_five A vector can also contain characters: primary_colors &lt;- c(&quot;red&quot;, &quot;yellow&quot;, &quot;blue&quot;) primary_colors There are many functions that allow you to inspect the content of a vector. length() tells you how many elements are in a particular vector: length(one_to_five) length(primary_colors) You can also do math with whole vectors. For instance if we wanted to multiply all the values in our vector by a scalar, we can do 5 * one_to_five or we can add the data in the two vectors together two_to_ten &lt;- one_to_five + one_to_five two_to_ten This is very useful if we have data in different vectors that we want to combine or work with. There are few ways to figure out what’s going on in a vector. class() indicates the class (the type of element) of an object: class(one_to_five) class(primary_colors) new_digits &lt;- c(one_to_five, 90) # adding at the end new_digits &lt;- c(30, new_digits) # adding at the beginning new_digits What happens here is that we take the original vector one_to_five, and we are adding another item first to the end of the other ones, and then another item at the beginning. We can do this over and over again to build a vector or a dataset. As we program, this may be useful to autoupdate results that we are collecting or calculating. We just saw 2 of the data types that R uses: &quot;character&quot; and &quot;integer&quot;. The others you will likely encounter during data analysis are: &quot;logical&quot; for TRUE and FALSE (the boolean data type) &quot;numeric&quot; for floating point decimal numbers &quot;factor&quot; for categorical data. Similar to &quot;character&quot; data, but factors have levels Importantly, a vector can only contain one data type. If you combine multiple data types in a vector with the c() command, R will try to coerce all the values to the same data type. If it cannot, it will throw an error. For example, what data type is our one_to_five vector if we divide it by 2? divided_integers &lt;- one_to_five/2 divided_integers class(divided_integers) Vectors are indexed sets, which means that every value can be referred to by its order in the vector. R indexes start at 1. Programming languages like Fortran, MATLAB, and R start counting at 1, because that’s what human beings typically do. Languages in the C family (including C++, Java, Perl, and Python) count from 0 because that’s simpler for computers to do. We can index a vector in many different ways. We can specify a position of a single value, a range of values, or a vector of values. We can even specify which values to remove by their indices. one_to_five[3] one_to_five[1:3] one_to_five[c(1, 3, 5)] one_to_five[-2] "],
["2-7-other-data-structures.html", "2.7 Other data structures", " 2.7 Other data structures Vectors are one of the many data structures that R uses. Other important ones are lists (list), matrices (matrix), and data frames (data.frame) -->"],
["3-data-frames.html", "Lesson 3 Data frames 3 Learning Objectives", " Lesson 3 Data frames 3 Learning Objectives load external data (CSV files) in memory understand the concept of a data.frame know how to access any element of a data.frame understand factors and how to manipulate them "],
["3-1-setup.html", "3.1 Setup", " 3.1 Setup The file required for this lesson can be downlaoded by clicking on this link Move the downloaded file into the directory for this workshop To view your current working directory use the getwd() command To set you working directory, use the setwd() command. We want to set the working directory to the location of our project. For example: setwd(&quot;~/Workshops/AARUG&quot;) "],
["3-2-looking-at-data.html", "3.2 Looking at data", " 3.2 Looking at data You are now ready to load the data. We are going to use the R function read.csv() to load the data file into memory (as a data.frame). In this case, our data is in a subdirectory called “data”. cats &lt;- read.csv(file = &#39;data/herding-cats-small.csv&#39;) This statement doesn’t produce any output because assignment doesn’t display anything. If we want to check that our data has been loaded, we can print the variable’s value: cats. cats However, if our dataset was larger, we probably wouldn’t want to print the whole thing to our console. Instead, we can use the head command to view the first six lines or the View command to open the dataset in a spreadsheet-like viewer. head(cats) View(cats) We’ve just done two very useful things. 1. We’ve read our data in to R, so now we can work with it in R 2. We’ve created a data frame (with the read.csv command) the standard way R works with data. "],
["3-3-what-are-data-frames.html", "3.3 What are data frames?", " 3.3 What are data frames? data.frame is the de facto data structure for most tabular data and what we use for statistics and plotting. A data.frame is actually a list of vectors of identical lengths. Each vector represents a column, and each vector can be of a different data type (e.g., characters, integers, factors). The str() function is useful to inspect the data types of the columns. A data.frame can be created by the functions read.csv() or read.table(), in other words, when importing spreadsheets from your hard drive (or the web). By default, data.frame converts (= coerces) columns that contain characters (i.e., text) into the factor data type. Depending on what you want to do with the data, you may want to keep these columns as character. To do so, read.csv() and read.table() have an argument called stringsAsFactors which can be set to FALSE: Let’s now check the structure of this data.frame in more details with the function str(): str(cats) "],
["3-4-inspecting-data-frame-objects.html", "3.4 Inspecting data.frame objects", " 3.4 Inspecting data.frame objects We already saw how the functions head() and str() can be useful to check the content and the structure of a data.frame. Here is a non-exhaustive list of functions to get a sense of the content/structure of the data. Size: dim() - returns a vector with the number of rows in the first element, and the number of columns as the second element (the dimensions of the object) nrow() - returns the number of rows ncol() - returns the number of columns Content: head() - shows the first 6 rows tail() - shows the last 6 rows Names: names() - returns the column names (synonym of colnames() for data.frame objects) rownames() - returns the row names Summary: str() - structure of the object and information about the class, length and content of each column summary() - summary statistics for each column Note: most of these functions are “generic”, they can be used on other types of objects besides data.frame. "],
["3-5-indexing-data-frame-objects.html", "3.5 Indexing data.frame objects", " 3.5 Indexing data.frame objects Our cats data frame has rows and columns (it has 2 dimensions), if we want to extract some specific data from it, we need to specify the “coordinates” we want from it. Row numbers come first, followed by column numbers (i.e. [row, column]). cats[1, 2] # first element in the 2nd column of the data frame cats[1, 6] # first element in the 6th column cats[1:3, 7] # first three elements in the 7th column cats[3, ] # the 3rd element for all columns cats[, 7] # the entire 7th column head_meta &lt;- cats[1:6, ] # Row 1-6 which is the same as head For larger datasets, it can be tricky to remember the column number that corresponds to a particular variable. (Are species names in column 5 or 7? oh, right… they are in column 6). In some cases, in which column the variable will be can change if the script you are using adds or removes columns. It’s therefore often better to use column names to refer to a particular variable, and it makes your code easier to read and your intentions clearer. You can do operations on a particular column, by selecting it using the $ sign. In this case, the entire column is a vector. You can use names(cats) or colnames(cats) to remind yourself of the column names. For instance, to extract all the cats’ weight information from our dataset: cats$weight In some cases, you may way to select more than one column. You can do this using the square brackets, passing in a vector of the columns to select. Suppose we wanted weight and coat information: cats[ , c(&quot;weight&quot;, &quot;coat&quot;)] You can even access columns by column name and select specific rows of interest. For example, if we wanted the weight and coat of just rows 4 through 7, we could do: cats[4:7, c(&quot;weight&quot;, &quot;coat&quot;)] We can can also use logical statements to select and filter items from a data.frame. For example, to select all rows with black cats we could use the following statement cats[cats$coat == &quot;black&quot;, ] let’s break this down a bit. The logical statement in the brackets returns a vector of TRUE and FALSE values. cats$coat == &quot;black&quot; These booleans allow us to select which records we want from our data.frame Another way to do this is with the function which(). which() finds the indexes of records meeting a logical statement which(cats$coat == &quot;black&quot;) So, we could also write cats[which(cats$coat == &quot;black&quot;), ] But that’s getting really long and ugly. R is already considered somewhat of an ugly duckling among programming languages, so no reason to play into the stereotype. We can combine logical statements and index statements cats[cats$coat == &quot;black&quot;, c(&quot;coat&quot;, &quot;weight&quot;)] Finally, we can use &amp;, the symbol for “and”, and |, the symbol for “or”, to make logical statements. cats[cats$coat == &quot;black&quot; &amp; cats$roamer == &quot;no&quot;, ] This statement selects all records with black cats that also like string "],
["3-6-factors.html", "3.6 Factors", " 3.6 Factors Factors are used to represent categorical data. Factors can be ordered or unordered and are an important class for statistical analysis and for plotting. Factors are stored as integers, and have labels associated with these unique integers. While factors look (and often behave) like character vectors, they are actually integers under the hood, and you need to be careful when treating them like strings. In the data frame we just imported, let’s do str(cats) We can see the names of the multiple columns. And, we see that coat is a Factor w/ 5 levels When we read in a file, any column that contains text is automatically assumed to be a factor. Once created, factors can only contain a pre-defined set values, known as levels. By default, R always sorts levels in alphabetical order. You can check this by using the function levels(), and check the number of levels using nlevels(): levels(cats$coat) nlevels(cats$coat) Sometimes, the order of the factors does not matter, other times you might want to specify the order because it is meaningful (e.g., “low”, “medium”, “high”) or it is required by particular type of analysis. Additionally, specifying the order of the levels allows to compare levels: satisfaction &lt;- factor(c(&quot;low&quot;, &quot;high&quot;, &quot;medium&quot;, &quot;high&quot;, &quot;low&quot;, &quot;medium&quot;, &quot;high&quot;)) levels(satisfaction) satisfaction &lt;- factor(satisfaction, levels = c(&quot;low&quot;, &quot;medium&quot;, &quot;high&quot;)) levels(satisfaction) min(satisfaction) ## doesn&#39;t work ## Error in Summary.factor(structure(c(1L, 3L, 2L, 3L, 1L, 2L, 3L), .Label = c(&quot;low&quot;, : &#39;min&#39; not meaningful for factors satisfaction &lt;- factor(satisfaction, levels = c(&quot;low&quot;, &quot;medium&quot;, &quot;high&quot;), ordered = TRUE) levels(satisfaction) min(satisfaction) ## works! In R’s memory, these factors are represented by numbers (1, 2, 3). They are better than using simple integer labels because factors are self describing: &quot;low&quot;, &quot;medium&quot;, and &quot;high&quot;&quot; is more descriptive than 1, 2, 3. Which is low? You wouldn’t be able to tell with just integer data. Factors have this information built in. It is particularly helpful when there are many levels (like the species in our example data set). 3.6.1 Converting factors If you need to convert a factor to a character vector, simply use as.character(x). Converting a factor to a numeric vector is however a little trickier, and you have to go via a character vector. Compare: f &lt;- factor(c(1, 5, 10, 2)) as.numeric(f) ## wrong! and there is no warning... as.numeric(as.character(f)) ## works... as.numeric(levels(f))[f] ## The recommended way. -->"],
["4-extending-r-with-packages.html", "Lesson 4 Extending R with Packages 4 Learning Objectives", " Lesson 4 Extending R with Packages 4 Learning Objectives Know what packages are and how to install them from CRAN Packages are bundles of code which extend the functionality of R. Anyone can make an R package, and anyone can intall anyone else’s R package (if they make it available). This is part of the beauty of open source, and using different R packages is essential to modern R workflows. You can get packages from many different places, but we’ll focus on just the most common one: CRAN. CRAN is the Comprehensive R Archive Network, a global network of servers which make available for download a set of vetted R packages. The next section is about RMarkdown, a package, so we’ll install that now. "],
["4-1-installation.html", "4.1 Installation", " 4.1 Installation To download and install a package from CRAN, call the install.packages command on a string with the name of the desired package: install.packages(&quot;rmarkdown&quot;) You may be asked to choose a mirror; the RStudio mirror is a good choice as it will pick the nearest mirror automatically. This will also download and install packages which RMarkdown depends on. You only need to install a package once per machine, unless you need to update an already-installed package. Calling install.packages for an existing package will update it if there’s a more recent version on CRAN than on your machine. "],
["4-2-loading.html", "4.2 Loading", " 4.2 Loading Most packages need to be loaded into the current environment to be accessible. RMarkdown is specially integrated in RStudio in a way that avoids this, but in general we load packages with the library command: library(somepackage) # notice the lack of quotes This will come up again later in the lesson on dplyr, an external package that does need to be loaded. -->"],
["5-r-markdown.html", "Lesson 5 R Markdown 5 Learning Objectives", " Lesson 5 R Markdown 5 Learning Objectives Understand why literate programming is useful Create and edit an RMarkdown file Know how to manipulate some common chunk options R Markdown is a special file format which allows us to combine text, code, and the output of that code in a single file. This combination of explanation, code, and results is called literate programming and is a powerful way to share research and data explorations. RMarkdown is an extended version of the Markdown (.md) file format, which is an easy way to make nicely formatted text documents without endlessly tinkering with the formatting (as you might with LaTeX). The software community loves Markdown because in addition to being straightforward, it has good support for formatting code, which can be a pain in other formats. RMarkdown takes this a step further by allowing you to run the code in your document, and having the output appear below the code that made it. If you’ve used ipython/Jupyter notebooks before, R Markdown will feel similar. All the lessons in this workshop were created with R Markdown! "],
["5-1-my-first-rmd.html", "5.1 My First Rmd", " 5.1 My First Rmd Rstudio makes it easy to create a new RMarkdown file, and it even starts with a demo file that shows off most of the basic features of the Rmd format. In the upper-left corner, click the “new file” icon and select RMarkdown. A window should appear to help you configure this file initially. There’s a lot of options (R Markdown can do so much!), but for now, make sure your name is in the “Author” field, and change the “Title” to be something like “AARUG Workshop”. Before we delve into what each of these pieces mean, let’s “knit” the document so we can see what kind of output RMarkdown produces. Above the file, press the knit button, the one that looks like a ball of yarn. You should see a new pane open in RStudio that shows R “knitting” the document, and when it’s done, a pop-up will appear showing the knitted output. This new output being displayed is an html file; look in the file browser pane, and you’ll see a .html file next to your .Rmd file (may need to refresh), because RStudio automatically saved this output when the document finished knitting. Let’s look at the individual pieces in this document: 5.1.1 Header This is the section at the top, with three dashes before and after. This lists some metadata about the object. The title, date, and author form the start of the output document, and the output: line instructs the knitting process to generate an html file. 5.1.2 Section Titles You can enlarge text be preceding it with one or more pound signs (#). This is mainly useful for organizing a document into sections. The more pound signs, the smaller the text, so when you make sub-section you should add at least one more pound sign than used in the parent sections’ title. 5.1.3 Link Notice the link in the first section, wrapped in angle brackets (&lt;, &gt;). This makes that text a clickable link. 5.1.4 Bold/Italic Text The double-asterisks surrounding the word “Knit” in the second paragraph cause that piece of text to be bold. This phrase can be multiple words, but should not have spaces immediately on the inside of the asterisks. You can make text italix by similarly wrapping in underscores (_). 5.1.5 Code Chunks This is the real meat of the document! An R Markdown code chunk is a section which starts and ends with triple-backticks (`, not '). After the initial set, the curly-bracketed section which starts with {r is what forces this to be ran as R code; without this piece, the section would get formatted like code, but would not be executed when knitting. The phrase after the r is the chunk name. Chunks do not need to be named, but no two chunks can have the same name. Naming chunks can help keep code organized and make it easier to track down the source of errors when they occur. 5.1.5.1 Chunk Options As the second default section discusses, we can hide the code in a code chunk by placing a comma after out chunk name and setting an option echo=FALSE. The code will still execute, and its output will be inserted in the knitted document, but it will not be shown. Similarly, you can set eval=FALSE to avoid running a code chunk. "],
["5-2-digging-deeper.html", "5.2 Digging Deeper", " 5.2 Digging Deeper There’s a lot more to RMarkdown than just this; as the demo document shows, you can visit http://rmarkdown.rstudio.com to learn more. We’ll be using R Markdown for the rest of this workshop to keep a running log of what we’re learning. This will allow you to walk away with a knit document which has not only the code commands you’ve learned to use, but the output of those commands and some explanatory text. That’s literate programming! -->"],
["6-data-visualization.html", "Lesson 6 Data visualization Learning Objectives", " Lesson 6 Data visualization Learning Objectives Grammar of graphics concepts (geoms, aesthetics) Advanced plots (scales, facets, themes) Writing images (and other things) to file "],
["6-1-built-in-plotting-functions.html", "6.1 Built in plotting functions", " 6.1 Built in plotting functions When working with large sets of numbers it can be useful to display that information graphically. R has a number of built-in functions for creating plots such as histograms, scatter plots, bar charts, boxplots and much more. We’ll try these out using the cats data introduced earlier. The plot() function provides a method for generic x and y plotting (e.g. scatter plots). Scatter plot Let’s start by creating a scatter plot. A scatter plot provides a graphical view of the relationship between two sets of numbers. We can create a scatter plot using the plot() function and supplying the x and y coordinates of the points. Using the cats data, we can make a scatterplot of kitten birth weight by mother’s age. cats &lt;- read.csv(&quot;data/herding-cats.csv&quot;) plot(x = cats$age, y = cats$weight) Each point represents a row in our dataset. The value on the x-axis is the mother’s age and the values on the y-axis correspond to the birth weight for the infant. For any plot you can customize many features of your graphs (fonts, colors, axes, titles) through graphic options. plot(x = cats$age, y = cats$weight, xlim = c(0, 10), ylim = c(0, 15), xlab = &quot;Age&quot;, ylab = &quot;Weight&quot;, main = &quot;Weight by Age&quot;, las = 1, col = factor(cats$coat)) In this example "],
["6-2-ggplot2.html", "6.2 ggplot2", " 6.2 ggplot2 More recently, R users have moved away from base graphic options and towards a plotting package called ggplot2 that adds a lot of functionality to the basic plots seen above. The syntax is different but it’s extremely powerful and flexible. We can start by re-creating some of the above plots but using ggplot functions to get a feel for the syntax. Install and load the ggplot2 package. # install.packages(&quot;ggplot2&quot;) library(ggplot2) The ggplot() function is used to initialize the basic graph structure, then we add to it. The basic idea is that you specify different parts of the plot, and add them together using the + operator. We will start with a blank plot and will find that you will get an error, because you need to add layers. ggplot(cats) Geometric objects are the actual marks we put on a plot. Examples include: points (geom_point, for scatter plots, dot plots, etc) lines (geom_line, for time series, trend lines, etc) boxplot (geom_boxplot, for, well, boxplots!) A plot must have at least one geom; there is no upper limit. You can add a geom to a plot using the + operator. ggplot(cats) + geom_point() Each type of geom usually has a required set of aesthetics to be set, and usually accepts only a subset of all aesthetics –refer to the geom help pages to see what mappings each geom accepts. Aesthetic mappings are set with the aes() function. Examples include: position (i.e., on the x and y axes) color (“outside” color) fill (“inside” color) shape (of points) linetype size To start, we will add position for the x- and y-axis since geom_point requires mappings for x and y, all others are optional. ggplot(cats) + geom_point(aes(x = age, y = weight), color = &quot;red&quot;, alpha = 0.5, shape = 1, size = 3) 6.2.1 Scales Scales control the mapping between data and aesthetics. ggplot(cats) + geom_point(aes(x = age, y = weight)) + scale_x_continuous(name = &quot;Age&quot;, breaks = c(1, 2, 3), limits = c(-5, 15)) + scale_y_continuous(&quot;Weight&quot;, trans = &quot;log&quot;) + ggtitle(label = &quot;Scatterplot&quot;) 6.2.2 Themes The ggplot2 theme system handles non-data plot elements such as: Axis labels Plot background Facet label backround Legend appearance There are built-in themes we can use, or we can adjust specific elements. We can add additional aesthetics by mapping them to other variables in our dataframe. For example, the color of the boxplots will reflect low birth weight. ggplot(cats) + geom_point(aes(x = age, y = weight)) + theme_bw() 6.2.3 Facets Facets display subsets of the dataset in different panels. Let’s use the facet_grid function to lay out panels in a grid. Each panel will have the same geometric objects. ggplot(cats) + geom_point(aes(x = age, y = weight)) + xlab(&quot;Mother&#39;s age&quot;) + ylab(&quot;Birth weight&quot;) + facet_grid(. ~ coat) + theme_linedraw() Here we have two panels one for each factor level of coat. The panels are layed out in columns because the expression . ~ coat 6.2.4 Writing figures to file There are two ways in which figures and plots can be output to a file (rather than simply displaying on screen). The first (and easiest) is to export directly from the RStudio ‘Plots’ panel, by clicking on Export when the image is plotted. This will give you the option of png or pdf and selecting the directory to which you wish to save it to. The second option is to use R functions in the console, allowing you the flexibility to specify parameters to dictate the size and resolution of the output image. Some of the more popular formats include pdf(), png, and svg. Initialize a plot that will be written directly to a file using pdf, png etc. Within the function you will need to specify a name for your image, and the with and height (optional). Then create a plot using the usual functions in R. Finally, close the file using the dev.off() function. There are also bmp, tiff, and jpeg functions, though the jpeg function has proven less stable than the others. pdf(&quot;figure/boxplot.pdf&quot;) ggplot(example_data) + geom_boxplot(aes(x = cit, y =....) + ggtitle(...) + xlab(...) + ylab(...) + theme(panel.grid.major = element_line(...), axis.text.x = element_text(...), axis.title = element_text(...), axis.text = element_text(...) dev.off() "],
["6-3-additional-resources.html", "6.3 Additional resources", " 6.3 Additional resources We only scratched the surface in this section. There are many more ggplot2 features we haven’t covered and other packages for data visualization. plotting in Base R: John Maindonald’s Using R for Data Analysis and Graphics PDF ggplot2: ggplot reference site Winston Chang’s excellent Cookbook for R ggplot2: Elegant Graphics for Data Anaysis Much of the material here was adpapted from Introduction to R graphics with ggplot2 Tutorial at IQSS. -->"]
]
